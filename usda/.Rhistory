get.adjacency(g, attr = "weight")
get.adjacency(g)
g <- alldata$partial$g_3$agg_graph
get.adjacency(g, attr = "weight")
get.adjacency(g)
get.adjacency(g, attr = "weight")
get.adjacency(g)
get_sanctions <- function(dat){
dat <- read.csv(dat)
names(dat) <- tolower(names(dat))
## recode subject numbers
dat$sender <- with(dat,
ifelse(
sender > 8,
sender - 8,
sender
)
)
dat$receiver <- with(dat,
ifelse(
receiver > 8,
receiver - 8,
receiver
)
)
## rename "Points" to "Weight"
names(dat)[names(dat)=="points"] <-  "weight"
# return
return(dat)
}
get_atts <- function(dat,treatment, treatment_n){
require(foreign)
dat <- read.dta(dat)
# subset data
keep_cols <- c("treatment", "period","subject", "group", "type", "h", "ip", "fp", "typep")
dat <- dat[dat$treatment == treatment, colnames(dat) %in% keep_cols]
## return subject numbers to 1-8
dat$subject <- dat$subject - (dat$group*100)
dat$subject <- with(dat,
ifelse(
subject > 8,
subject - 8,
subject
)
)
## return group numbers 1 - 4
dat$group <- dat$group - 10*treatment_n
## recode type to 1 (insider) or 2 (outsider)
dat$type <- with(dat,
ifelse(
type == "Insider",
1,
2
)
)
## return
dat <- droplevels(dat)
return(dat)
}
get_treatment <- function(sanctions, attributes, treatment, treatment_n){
dat_list <- list()
# sanctions data
dat_list[["dat.s"]] <- get_sanctions(sanctions)
# attributes
dat_list[["dat.atts"]] <- get_atts(attributes, treatment, treatment_n)
return(dat_list)
}
make_graphs <- function(dat_list, grp_n, treatment_abbrv, agg, delete, delete_type){
dat.s <- dat_list[[1]]
dat.s <- dat.s[dat.s$group == grp_n,]
dat.atts <- dat_list[[2]]
dat.atts <- dat.atts[dat.atts$group == grp_n,]
graph_list <- list()
require(igraph)
if(agg==T){
## aggregate graph
agg_graph <- simplify(graph.data.frame(dat.s[c("sender", "receiver", "weight")]))
### add attributes type, h, ip
require(data.table)
summary.atts <- data.table(dat.atts)[,list(h = sum(h), ip=sum(ip), fp=sum(fp) ), by = .(treatment, subject, type)]
V(agg_graph)$type = summary.atts$type[match(V(agg_graph)$name, summary.atts$subject)]
V(agg_graph)$h = summary.atts$h[match(V(agg_graph)$name, summary.atts$subject)]
V(agg_graph)$ip = summary.atts$ip[match(V(agg_graph)$name, summary.atts$subject)]
V(agg_graph)$fp = summary.atts$ip[match(V(agg_graph)$name, summary.atts$subject)]
#E(agg_graph)$type <- V(agg_graph)$type[ends(agg_graph, es=E(agg_graph), names=F)[,2]]
if(delete==T){
agg_graph <- delete.edges(agg_graph, which(E(agg_graph)$type == delete_type))
}
agg_graph <- delete.edges(agg_graph, which(E(agg_graph)$weight == 0))
### add to list
graph_list$agg_graph <- agg_graph
}
## create graph for each time step
niter <- length(unique(dat.s$period))
for(i in 1:niter){
# get the data ready
group.p <- dat.s[dat.s$period == i,]
group.p.edgelist <- group.p[c("sender", "receiver", "weight")]
# make the graph
graph <- graph.data.frame(group.p.edgelist)
graph <- delete.edges(graph, which(E(graph)$weight == 0))
# ADD ATTRIBUTES
group.atts <- dat.atts[dat.atts$period == i,]
## add subject type
V(graph)$type <- group.atts$type[match(V(graph)$name, group.atts$subject)]
## add harvest
V(graph)$h <- group.atts$h[match(V(graph)$name, group.atts$subject)]
## add initial payoff
V(graph)$ip <- group.atts$ip[match(V(graph)$name, group.atts$subject)]
## add final payoff
V(graph)$fp <- group.atts$fp[match(V(graph)$name, group.atts$subject)]
## add monitoring
V(graph)$mon <- as.numeric(group.atts$typep[match(V(graph)$name, group.atts$subject)])
## add type as edge attribute via ends() (note: 2nd column of matrix is edge target, first column is origin)
E(graph)$type <- V(graph)$type[ends(graph, es=E(graph), names=F)[,2]]
if(delete==T){
graph <- delete.edges(graph, which(E(graph)$type == delete_type))
}
# store the graph and add to list
new_entry <- paste(paste(treatment_abbrv, ".g", sum(dat.s$group)/nrow(dat.s), sep=""), i, sep = ".")
graph_list[[new_entry]] <- graph
}
# return list of graphs
return(graph_list)
}
load_data <- function(sanctions, attributes, treatment, treatment_abbrv, treatment_n, agg, delete, delete_type){
dat <- get_treatment(sanctions, attributes, treatment, treatment_n)
graphs_all_groups <- list()
suppressWarnings(
for (i in 1:4){
group = paste0("g_",i)
graphs_all_groups[[group]] <- make_graphs(dat,i,treatment_abbrv,agg, delete, delete_type)
}
)
return(graphs_all_groups)
}
get_all_data <- function(agg, delete, delete_type) {
# ZERO MONITORING
zero_dat <- load_data("~/Desktop/notebook/research/dissertation/third_paper/enforcement-networks/data/punishment_zm.csv",
"~/Desktop/notebook/research/dissertation/third_paper/enforcement-networks/data/dp_data_R.dta",
"ZERO", "zm", 1, agg, delete, delete_type)
# PARTIAL MONITORING
partial_dat <- load_data("~/Desktop/notebook/research/dissertation/third_paper/enforcement-networks/data/punishment_pm.csv",
"~/Desktop/notebook/research/dissertation/third_paper/enforcement-networks/data/dp_data_R.dta",
"PARTIAL", "pm", 2, agg, delete, delete_type)
# FULL MONITORING
full_dat <- load_data("~/Desktop/notebook/research/dissertation/third_paper/enforcement-networks/data/punishment_fm.csv",
"~/Desktop/notebook/research/dissertation/third_paper/enforcement-networks/data/dp_data_R.dta",
"FULL", "fm", 3, agg, delete, delete_type)
# combine into level three list
alldata <- list(zero = zero_dat, partial = partial_dat, full = full_dat)
return(alldata)
}
# function to get various summary measures, set up to make ggplotting easier
get_measure <- function(combined_data, measure, options=F, option){
return_list <- list()
for(i in 1:3){
treatment <- paste0("treatment",i)
treatment <- list()
for(j in 1:4){
if(options==F){
treatment[[j]] <- sapply(combined_data[[i]][[paste0("g_",j)]],measure)
} else if(options == T) {
treatment[[j]] <- sapply(combined_data[[i]][[paste0("g_",j)]], function(x) measure(x, mode=option))
}
}
return_list[[i]] <- treatment
}
return_list <- lapply(return_list, unlist, use.names = FALSE)
return_df <- data.frame(
"value" = unlist(return_list),
"treatment" = rep(c('ZERO', 'PARTIAL', 'FULL'), each=60),
"group" = rep(1:4, times=3, each=15),
"period" = rep(1:15, 4*3)
)
return_df$treatment <- ordered(return_df$treatment, levels = c('ZERO', 'PARTIAL', 'FULL'))
return(return_df)
}
# custom graph plot function
# note 7/26/17: latest igraph update renders plots oddly
plot_graph <- function(g, color_edges=F){
if (!is.igraph(g)) {
stop("Not a graph object")
}
## vertices
V(g)$rankh <- rank(V(g)$h / max(V(g)$h))
nodeSize <- V(g)$rankh*5
V(g)$in_degree <- order(-graph.strength(g, mode = "in"))
V(g)$out_degree <- order(-graph.strength(g, mode = "out"))
V(g)$ev <- order(-page.rank(g, directed = TRUE)$vector)
vertexColor <- ifelse(
V(g)$name == V(g)$in_degree[1], "lightblue",
ifelse(
V(g)$name == V(g)$out_degree[1], "lightgreen",
"gray")
)
frameColor_initial <- ifelse(
V(g)$name == V(g)$in_degree[1], "lightblue",
ifelse(
V(g)$name == V(g)$out_degree[1], "lightgreen",
"gray"
)
)
frameColor_updated <- ifelse(
V(g)$name == V(g)$ev[1], "red", frameColor_initial
)
## edges
g <- delete.edges(g, which(E(g)$weight ==0))
E(g)$normalizedEdges <- E(g)$weight / max(E(g)$weight)
nodeShape = ifelse(V(g)$type == 1, "circle", "square")
edgeSize = E(g)$normalizedEdges * 5
E(g)$curved = TRUE
## layout & plot
set.seed(15)
#layout=layout.fruchterman.reingold(g, niter=500)
layout=layout_as_star(g)
plot.igraph(g,
#layout=layout,
edge.width=edgeSize,
edge.arrow.size=0.25,
edge.color = ifelse(color_edges == F, "black", E(g)$type),
edge.color = E(g)$type,
vertex.color = vertexColor,
vertex.size = nodeSize,
vertex.frame.color = frameColor_updated,
vertex.label.color = "white",
vertex.label = NA,
vertex.shape = nodeShape
)
}
plot_treatment <- function(treatment){
op <- par(mfrow = c(2, 2), mar=rep(1,4), oma=c(0,0,2,0), pty = "s")
for(i in 1:4){
group <- paste0("g_",i,sep="")
plot_graph(treatment[[group]][["agg_graph"]]); title(paste0("Group", " ", i,sep=""))
}
par(op)
}
get_stats_dataframe <- function(treatment){
fulldata <- data.frame()
for(i in 1:4){
group <- paste0("g_",i,sep="")
# start by getting the out-degree (weight) and use this to set up data frame
dat <- sapply(treatment[[group]], function(x) graph.strength(x, mode="out"))
dat <- reshape2::melt(dat)
dat$Var2 <- NULL
colnames(dat) <- c("subject", "out_degree_weight")
# now add other stats
## INDIVIDUAL
## out-degree (edges)
dat$out_degree_edges <- reshape2::melt(sapply(treatment[[group]], function(x) degree(x, mode="out")))[,3]
## in-degree (weight)
dat$in_degree_weight <- reshape2::melt(sapply(treatment[[group]], function(x) graph.strength(x, mode="in")))[,3]
## in-degree (edges)
dat$in_degree_edges <- reshape2::melt(sapply(treatment[[group]], function(x) degree(x, mode="in")))[,3]
## GROUP
dat$reciprocity <- rep(reshape2::melt(sapply(treatment[[group]], reciprocity))[,1],each=8)
dat$transitivity <- rep(reshape2::melt(sapply(treatment[[group]], transitivity))[,1],each=8)
dat$density <- rep(reshape2::melt(sapply(treatment[[group]], edge_density))[,1],each=8)
# lastly, add period, group etc and export
## add period
dat$period <- rep(1:15,each=8)
## add group
dat$group <- i
## add unique subject_id
dat$subject_id <- dat$subject + (dat$group * 100)
## bind it to full data frame
fulldata <- rbind(fulldata, dat)
}
# drop subject
fulldata$subject <- NULL
# replace NaN's with zeros
fulldata <- replace(fulldata, is.na(fulldata), 0)
# order the data
refcols <- c("subject_id", "period", "group")
fulldata <- fulldata[, c(refcols, setdiff(names(fulldata), refcols))]
# sort the data
fulldata <- fulldata[with(fulldata, order(subject_id, period, group)), ]
return(fulldata)
}
alldata <- get_all_data(agg = T, delete = F)
g <- alldata$partial$g_3$agg_graph
get.adjacency(g, attr = "weight")
get.adjacency(g)
plot_degree_distribution(g)
get.adjacency(g)
get.adjacency(g, attr = "weight")
get.adjacency(g)
plot_degree_distribution(g)
plot_degree_distribution(g)
get.adjacency(g)
get.adjacency(g, attr = "weight")
plot_graph(g)
hist(degree(g))
hist(degree(g, mode = "out"))
hist(degree(g, mode = "out"))
qplot(degree(g, mode = "out"))
qplot(degree(g, mode = "out"), geom = "density")
qplot(degree(g, mode = "out"), geom = "density", theme = "classic")
?qplot
qplot(degree(g, mode = "out"), geom = "density") + theme_classic()
qplot(degree(g, mode = "out"), geom = "density")
qplot(degree(g, mode = "out"))
g <- alldata$full$g_4$agg_graph
transitivity(alldata$full$g_4$agg_graph)
transitivity(alldata$full$g_2$agg_graph)
reciprocity(alldata$full$g_2$agg_graph)
matrix(c(1,1,1,1))
matrix(c(1,1,1,1), c(1,1,1,1,1))
matrix(c(1,1,1,1), c(1,1,1,1,1))
?matrix
matrix((c(1,1,1,1), c(1,1,1,1,1)), nrow=4, ncol=4)
matrix(c(1,2,3, 11,12,13), nrow = 2, ncol = 3, byrow = TRUE)
matrix(c(1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8), nrow = 8, ncol = 8, byrow = TRUE)
rep(0,5)
matrix(c(1,2,3,rep(0,5)), nrow = 8, ncol = 8, byrow = TRUE)
matrix(c(1,1,1,rep(0,5)), nrow = 8, ncol = 8, byrow = TRUE)
g <- graph( edges=c(
1,6, 1,7, 1,8,
2,6, 2,7, 2,8
3,6, 3,7, 3,8
4,6, 4,7, 4,8
5,6, 5,7, 5,8
),
n=8)
g <- graph( edges=c(1,6, 1,7, 1,8, 2,6, 2,7, 2,8 3,6, 3,7, 3,8 4,6, 4,7, 4,8 5,6, 5,7, 5,8), n=8)
g <- graph( edges=c(1,6, 1,7, 1,8, 2,6), n=8)
g
g <- graph( edges=c(1,6, 1,7, 1,8, 2,6, 2,7), n=8)
g <- graph( edges=c(1,6, 1,7, 1,8, 2,6, 2,7, 2,8 3,6, 3,7, 3,8 4,6, 4,7, 4,8, 5,6, 5,7, 5,8), n=8)
g <- graph( edges=c(1,6, 1,7, 1,8, 2,6, 2,7, 2,8 3,6,), n=8)
g <- graph( edges=c(1,6, 1,7, 1,8, 2,6, 2,7, 2,8 3,6), n=8)
g <- graph( edges=c(1,6, 1,7, 1,8, 2,6, 2,7, 2,8), n=8)
g <- graph( edges=c(1,6, 1,7, 1,8, 2,6, 2,7, 2,8, 1,1), n=8)
g <- graph( edges=c(1,6, 1,7, 1,8, 2,6, 2,7, 2,8, 3,1), n=8)
g <- graph( edges=c(1,6, 1,7, 1,8, 2,6, 2,7, 2,8, 3,6), n=8)
g <- graph( edges=c(1,6, 1,7, 1,8, 2,6, 2,7, 2,8, 3,6, 3,7), n=8)
g <- graph( edges=c(1,6, 1,7, 1,8, 2,6, 2,7, 2,8, 3,6, 3,7, 3,8), n=8)
g <- graph( edges=c(1,6, 1,7, 1,8, 2,6, 2,7, 2,8, 3,6, 3,7, 3,8, 4,6), n=8)
g <- graph( edges=c(1,6, 1,7, 1,8, 2,6, 2,7, 2,8, 3,6, 3,7, 3,8, 4,6, 4,7), n=8)
g <- graph( edges=c(1,6, 1,7, 1,8, 2,6, 2,7, 2,8, 3,6, 3,7, 3,8, 4,6, 4,7, 4,8), n=8)
g <- graph( edges=c(1,6, 1,7, 1,8, 2,6, 2,7, 2,8, 3,6, 3,7, 3,8, 4,6, 4,7, 4,8, 5,6, 5,7, 5,8), n=8)
g
get.adjacency(g)
plot(g)
transitivity(g)
reciprocity(g)
reciprocity(g)
plot(eigen(graph.laplacian(g))$values)
pm <- graph( edges=c(1,6, 2,6, 3,6, 4,6, 5,6), n=6)
fm <- graph( edges=c(1,6, 1,7, 1,8, 2,6, 2,7, 2,8, 3,6, 3,7, 3,8, 4,6, 4,7, 4,8, 5,6, 5,7, 5,8), n=8)
plot(eigen(graph.laplacian(pm))$values)
plot(make_star(5, mode = "directed"))
plot(make_star(5, mode = "mutual"))
plot(make_star(5, mode = "out"))
plot(make_star(5, mode = "in"))
plot(make_star(6, mode = "in"))
plot(make_star(5, mode = "in"))
plot(eigen(graph.laplacian(make_star(5, mode = "in")))$values)
library(dplyr)
library(ggplot2)
library(googleVis)
library(maps)
library(sjPlot)
setwd("~/Desktop/notebook/side_projects/usda/")
df <- read.csv("SFHG_Section_502_Guaranteed_By Congressional Dist 6.9.2016.csv")
nonstates <- c("PR", "VI", "WP")
df <- subset(df, !(State %in% nonstates))
mr_clean <- function(x) {
x <- gsub(",", "", x)
x <- as.numeric(x)
}
State <- df$State
df <- cbind(State, data.frame(apply(df[,-1], 2, mr_clean)))
names(df) <- gsub("[.]", "_", names(df))
df.sum <- df %>%
select(State, Active_Loans) %>%
group_by(State) %>%
summarise(total = sum(Active_Loans))
df.sum <- data.frame(df.sum)
names(df.sum) <- c("State", "Active Loans")
rownames(df.sum) <- rownames(USArrests)
GeoStates <- gvisGeoChart(df.sum, "State", "Active Loans",
options=list(region="US",
displayMode="regions",
resolution="provinces",
width=900, height=600))
plot(GeoStates)
library(dplyr)
library(ggplot2)
library(googleVis)
library(maps)
library(sjPlot)
setwd("~/Desktop/notebook/side_projects/usda/")
df <- read.csv("SFHG_Section_502_Guaranteed_By Congressional Dist 6.9.2016.csv")
nonstates <- c("PR", "VI", "WP")
df <- subset(df, !(State %in% nonstates))
mr_clean <- function(x) {
x <- gsub(",", "", x)
x <- as.numeric(x)
}
State <- df$State
df <- cbind(State, data.frame(apply(df[,-1], 2, mr_clean)))
names(df) <- gsub("[.]", "_", names(df))
df.sum <- df %>%
select(State, Active_Loans) %>%
group_by(State) %>%
summarise(total = sum(Active_Loans))
df.sum <- data.frame(df.sum)
names(df.sum) <- c("State", "Active Loans")
rownames(df.sum) <- rownames(USArrests)
USDA_Loans <- df.sum
GeoStates <- gvisGeoChart(USDA_Loans, "State", "Active Loans",
options=list(region="US",
displayMode="regions",
resolution="provinces",
width=900, height=600))
plot(GeoStates)
View(df)
hist(df$Active_Loans)
install.packages("glmnet")
names(df)
y <-as.matrix(df$Active_Loans)
y
names(df)
df[,-3]
head(df[,-3])
names(df[,-3])
names(df[,-1:3])
names(df[,-(1:3)])
x <- as.matrix(df[,-(1:3)])
m1 <- glmnet::cv.glmnet(x, y, family='poisson', alpha=1, standardize=TRUE, type.measure='auc')
m1 <- glmnet::cv.glmnet(x, y, family='poisson', alpha=0, standardize=TRUE, type.measure='auc')
m1 <- glmnet::cv.glmnet(x, y, family='poisson', alpha=0.5, standardize=TRUE, type.measure='auc')
m1 <- glmnet::cv.glmnet(x, y, family='poisson', alpha=1, standardize=TRUE, type.measure='auc')
plot(m1)
m1 <- glmnet::cv.glmnet(x, y, family='poisson', alpha=1, standardize=TRUE, type.measure='auc')
y <- as.matrix(df$Active_Loans)
x <- as.matrix(df[,-(1:3)])
x
class(x)
m1 <- glmnet::cv.glmnet(x, y, family='poisson', alpha=1, type.measure='auc')
sapply(df, class)
m1 <- glmnet::cv.glmnet(x, y, family='poisson', alpha=1, type.measure='auc', nfolds=10)
m1 <- glmnet::cv.glmnet(x, y, family='poisson', alpha=1, nfolds=10)
m1 <- glmnet::cv.glmnet(x, y, family='normal', alpha=1, nfolds=10)
m1 <- glmnet::cv.glmnet(x, y, family='gaussian', alpha=1, nfolds=10)
m1 <- glmnet::cv.glmnet(x, y, family='poisson', alpha=1, nfolds=10)
head(x)
is.na(x)
sapply(x, class)
table(sapply(x, class))
m1 <- glmnet::cv.glmnet(x, as.factor(y), family='poisson', alpha=1, nfolds=10)
any(y<0)
m1 <- glmnet::cv.glmnet(x, y, family='poisson', alpha=1, nfolds=10)
y <- as.double(df$Active_Loans)
x <- as.matrix(df[,-(1:3)])
m1 <- glmnet::cv.glmnet(x, y, family='poisson', alpha=1, nfolds=10)
m1 <- glmnet::cv.glmnet(x, y, family='poisson', alpha=0, nfolds=10)
m1 <- glmnet::cv.glmnet(x, y, family='poisson', alpha=1, nfolds=10)
View(x)
model.matrix(x)
glmnet(x, y, family = "poisson")
glmnet::glmnet(x, y, family = "poisson")
lm(y~x, data = x)
lm(y~x, data = as.dataframe(x))
lm(y~x, data = as.data.frame(x))
table(df$Unknown_Stucture)
table(is.na(x))
which(is.na(x))
which(is.na(df))
x <- x[-(which(is.na(x))),]
nrow(df)
nrow(x)
table(is.na(x))
x <- as.matrix(df[,-(1:3)])
x <- na.omit(x)
table(is.na(x))
nrow(x)
?which()
m1 <- glmnet::cv.glmnet(x, y, family='poisson', alpha=1, nfolds=10)
df.naomit <- na.omit(df)
y <- as.double(df$Active_Loans)
x <- as.matrix(df[,-(1:3)])
table(is.na(x))
df.naomit <- na.omit(df)
y <- as.double(df.naomit$Active_Loans)
x <- as.matrix(df.naomit[,-(1:3)])
table(is.na(x))
nrow(x)
m1 <- glmnet::cv.glmnet(x, y, family='poisson', alpha=1, nfolds=10)
glmnet::glmnet(x, y, family = "poisson")
plot(m1)
print(m1)
coef(m1)
m1 <- glmnet::cv.glmnet(x, y, family='poisson', alpha=0, nfolds=10)
plot(m1)
coef(m1)
plot(coef(m1))
hist(coef(m1))
coef(m1)
coef(m1)[1]
class(coef(m1))
hist(coef(m1)[1])
coef(m1)
plot(m1)
m1 <- glmnet::cv.glmnet(x, y, family='poisson', alpha=1, nfolds=10)
plot(m1)
plot(coef(m1))
alabama <- subset(df, State == "AL")
View(alabama)
sum(43 + 347 + 3110)
